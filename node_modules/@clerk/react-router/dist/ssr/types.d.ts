import { AuthObject, VerifyTokenOptions, Session, User, Organization } from '@clerk/backend';
import { RequestState } from '@clerk/backend/internal';
import { MultiDomainAndOrProxy, SignInForceRedirectUrl, SignInFallbackRedirectUrl, SignUpForceRedirectUrl, SignUpFallbackRedirectUrl, LegacyRedirectProps } from '@clerk/types';
import { LoaderFunction } from 'react-router';
import { CreateServerLoaderArgs } from 'react-router/route-module';

type Func = (...args: any[]) => unknown;
type RouteModule = {
    meta?: Func;
    links?: Func;
    headers?: Func;
    loader?: Func;
    clientLoader?: Func;
    action?: Func;
    clientAction?: Func;
    HydrateFallback?: unknown;
    default?: unknown;
    ErrorBoundary?: unknown;
    [key: string]: unknown;
};
type RouteInfo = {
    parents: RouteInfo[];
    module: RouteModule;
    id: unknown;
    file: string;
    path: string;
    params: unknown;
    loaderData: unknown;
    actionData: unknown;
};
type GetAuthReturn = Promise<AuthObject>;
type RootAuthLoaderOptions = {
    /**
     * Used to override the default VITE_CLERK_PUBLISHABLE_KEY env variable if needed.
     */
    publishableKey?: string;
    /**
     * Used to override the CLERK_JWT_KEY env variable if needed.
     */
    jwtKey?: string;
    /**
     * Used to override the CLERK_SECRET_KEY env variable if needed.
     */
    secretKey?: string;
    /**
     * @deprecated This option will be removed in the next major version.
     * Use session token claims instead: https://clerk.com/docs/backend-requests/making/custom-session-token
     */
    loadUser?: boolean;
    /**
     * @deprecated This option will be removed in the next major version.
     * Use session token claims instead: https://clerk.com/docs/backend-requests/making/custom-session-token
     */
    loadSession?: boolean;
    /**
     * @deprecated This option will be removed in the next major version.
     * Use session token claims instead: https://clerk.com/docs/backend-requests/making/custom-session-token
     */
    loadOrganization?: boolean;
    authorizedParties?: [];
    signInUrl?: string;
    signUpUrl?: string;
} & Pick<VerifyTokenOptions, 'audience'> & MultiDomainAndOrProxy & SignInForceRedirectUrl & SignInFallbackRedirectUrl & SignUpForceRedirectUrl & SignUpFallbackRedirectUrl & LegacyRedirectProps;
type RequestStateWithRedirectUrls = RequestState & SignInForceRedirectUrl & SignInFallbackRedirectUrl & SignUpForceRedirectUrl & SignUpFallbackRedirectUrl & LegacyRedirectProps;
type RootAuthLoaderCallback<Options extends RootAuthLoaderOptions> = (args: LoaderFunctionArgsWithAuth<Options>) => RootAuthLoaderCallbackReturn;
type ObjectLike = Record<string, unknown> | null;
/**
 * We are not using `LoaderFunctionReturn` here because we can't support non-object return values. We need to be able to decorate the return value with authentication state, and so we need something object-like.
 *
 * In the case of `null`, we will return an object containing only the authentication state.
 */
type RootAuthLoaderCallbackReturn = Promise<Response> | Response | Promise<ObjectLike> | ObjectLike;
type LoaderFunctionArgs = CreateServerLoaderArgs<RouteInfo>;
type LoaderFunctionReturn = ReturnType<LoaderFunction>;
type LoaderFunctionArgsWithAuth<Options extends RootAuthLoaderOptions = any> = LoaderFunctionArgs & {
    request: RequestWithAuth<Options>;
};
type RequestWithAuth<Options extends RootAuthLoaderOptions = any> = LoaderFunctionArgs['request'] & {
    auth: Omit<AuthObject, 'session' | 'user' | 'organization'>;
} & (Options extends {
    loadSession: true;
} ? {
    session: Session | null;
} : object) & (Options extends {
    loadUser: true;
} ? {
    user: User | null;
} : object) & (Options extends {
    loadOrganization: true;
} ? {
    organization: Organization | null;
} : object);

export type { GetAuthReturn, LoaderFunctionArgs, LoaderFunctionArgsWithAuth, LoaderFunctionReturn, RequestStateWithRedirectUrls, RequestWithAuth, RootAuthLoaderCallback, RootAuthLoaderCallbackReturn, RootAuthLoaderOptions, RouteInfo };
